{
  "version": 3,
  "sources": [
    "@uirouter/angular/lazyLoad/lazyLoadNgModule.ts"
  ],
  "names": [],
  "mappings": "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",
  "file": "lazyLoadNgModule.js",
  "sourceRoot": "",
  "sourcesContent": [
    "/** @ng2api @module core */\n/** */\nimport { NgModuleRef, Injector, NgModuleFactory, Type, Compiler, NgModuleFactoryLoader } from '@angular/core';\nimport {\n  Transition, LazyLoadResult, UIRouter, Resolvable, NATIVE_INJECTOR_TOKEN, isString, unnestR, inArray, StateObject,\n  uniqR, StateDeclaration\n} from '@uirouter/core';\nimport { RootModule, UIROUTER_ROOT_MODULE, UIROUTER_MODULE_TOKEN, StatesModule } from '../uiRouterNgModule';\nimport { applyModuleConfig } from '../uiRouterConfig';\n\n/**\n * A function that returns an NgModule, or a promise for an NgModule\n *\n * #### Example:\n * ```js\n * export function loadFooModule() {\n *   return System.import('../foo/foo.module').then(result => result.FooModule);\n * }\n * ```\n */\nexport type ModuleTypeCallback = () => Type<any> | Promise<Type<any>>;\n/**\n * A string or a function which lazy loads a module\n *\n * If a string, should conform to the Angular Router `loadChildren` string.\n * #### Example:\n * ```\n * var ngModuleToLoad = './foo/foo.module#FooModule'\n * ```\n *\n * For functions, see: [[ModuleTypeCallback]]\n */\nexport type NgModuleToLoad = string | ModuleTypeCallback;\n\n/**\n * Returns a function which lazy loads a nested module\n *\n * This is primarily used by the [[ng2LazyLoadBuilder]] when processing [[Ng2StateDeclaration.loadChildren]].\n *\n * It could also be used manually as a [[StateDeclaration.lazyLoad]] property to lazy load an `NgModule` and its state(s).\n *\n * #### Example:\n * Using `System.import()` and named export of `HomeModule`\n * ```js\n * declare var System;\n * var futureState = {\n *   name: 'home.**',\n *   url: '/home',\n *   lazyLoad: loadNgModule(() => System.import('./home/home.module').then(result => result.HomeModule))\n * }\n * ```\n *\n * #### Example:\n * Using a path (string) to the module\n * ```js\n * var futureState = {\n *   name: 'home.**',\n *   url: '/home',\n *   lazyLoad: loadNgModule('./home/home.module#HomeModule')\n * }\n * ```\n *\n *\n * @param moduleToLoad a path (string) to the NgModule to load.\n *    Or a function which loads the NgModule code which should\n *    return a reference to  the `NgModule` class being loaded (or a `Promise` for it).\n *\n * @returns A function which takes a transition, which:\n * - Gets the Injector (scoped properly for the destination state)\n * - Loads and creates the NgModule\n * - Finds the \"replacement state\" for the target state, and adds the new NgModule Injector to it (as a resolve)\n * - Returns the new states array\n */\nexport function loadNgModule(moduleToLoad: NgModuleToLoad): (transition: Transition, stateObject: StateDeclaration) => Promise<LazyLoadResult> {\n  return (transition: Transition, stateObject: StateDeclaration) => {\n    const ng2Injector = transition.injector().get(NATIVE_INJECTOR_TOKEN);\n\n    const createModule = (factory: NgModuleFactory<any>) =>\n        factory.create(ng2Injector);\n\n    const applyModule = (moduleRef: NgModuleRef<any>) =>\n        applyNgModule(transition, moduleRef, ng2Injector, stateObject);\n\n    return loadModuleFactory(moduleToLoad, ng2Injector)\n        .then(createModule)\n        .then(applyModule);\n  };\n}\n\n/**\n * Returns the module factory that can be used to instantiate a module\n *\n * For strings this:\n * - Finds the correct NgModuleFactoryLoader\n * - Loads the new NgModuleFactory from the path string (async)\n *\n * For a Type<any> or Promise<Type<any>> this:\n * - Compiles the component type (if not running with AOT)\n * - Returns the NgModuleFactory resulting from compilation (or direct loading if using AOT) as a Promise\n *\n * @internalapi\n */\nexport function loadModuleFactory(moduleToLoad: NgModuleToLoad, ng2Injector: Injector): Promise<NgModuleFactory<any>> {\n  if (isString(moduleToLoad)) {\n    return ng2Injector.get(NgModuleFactoryLoader).load(moduleToLoad);\n  }\n\n  const compiler: Compiler = ng2Injector.get(Compiler);\n  const offlineMode = compiler instanceof Compiler;\n\n  const unwrapEsModuleDefault = x =>\n      x && x.__esModule && x['default'] ? x['default'] : x;\n  const compileAsync = (moduleType: Type<any>) =>\n      compiler.compileModuleAsync(moduleType);\n\n  const loadChildrenPromise = Promise.resolve(moduleToLoad()).then(unwrapEsModuleDefault);\n  return offlineMode ? loadChildrenPromise : loadChildrenPromise.then(compileAsync);\n}\n\n/**\n * Apply the UI-Router Modules found in the lazy loaded module.\n *\n * Apply the Lazy Loaded NgModule's newly created Injector to the right state in the state tree.\n *\n * Lazy loading uses a placeholder state which is removed (and replaced) after the module is loaded.\n * The NgModule should include a state with the same name as the placeholder.\n *\n * Find the *newly loaded state* with the same name as the *placeholder state*.\n * The NgModule's Injector (and ComponentFactoryResolver) will be added to that state.\n * The Injector/Factory are used when creating Components for the `replacement` state and all its children.\n *\n * @internalapi\n */\nexport function applyNgModule(transition: Transition, ng2Module: NgModuleRef<any>, parentInjector: Injector, lazyLoadState: StateDeclaration): LazyLoadResult {\n  const injector = ng2Module.injector;\n  const uiRouter: UIRouter = injector.get(UIRouter);\n  const registry = uiRouter.stateRegistry;\n\n  const originalName = lazyLoadState.name;\n  const originalState = registry.get(originalName);\n  // Check if it's a future state (ends with .**)\n  const isFuture = /^(.*)\\.\\*\\*$/.exec(originalName);\n  // Final name (without the .**)\n  const replacementName = isFuture && isFuture[1];\n\n  const newRootModules = multiProviderParentChildDelta(parentInjector, injector, UIROUTER_ROOT_MODULE)\n      .reduce(uniqR, []) as RootModule[];\n  const newChildModules = multiProviderParentChildDelta(parentInjector, injector, UIROUTER_MODULE_TOKEN)\n      .reduce(uniqR, []) as StatesModule[];\n\n  if (newRootModules.length) {\n    console.log(newRootModules); // tslint:disable-line:no-console\n    throw new Error('Lazy loaded modules should not contain a UIRouterModule.forRoot() module');\n  }\n\n  const newStateObjects: StateObject[] = newChildModules\n      .map(module => applyModuleConfig(uiRouter, injector, module))\n      .reduce(unnestR, [])\n      .reduce(uniqR, []);\n\n  if (isFuture) {\n    const replacementState = registry.get(replacementName);\n    if (!replacementState || replacementState === originalState) {\n      throw new Error(`The Future State named '${originalName}' lazy loaded an NgModule. ` +\n          `The lazy loaded NgModule must have a state named '${replacementName}' ` +\n          `which replaces the (placeholder) '${originalName}' Future State. ` +\n          `Add a '${replacementName}' state to the lazy loaded NgModule ` +\n          `using UIRouterModule.forChild({ states: CHILD_STATES }).`);\n    }\n  }\n\n  // Supply the newly loaded states with the Injector from the lazy loaded NgModule.\n  // If a tree of states is lazy loaded, only add the injector to the root of the lazy loaded tree.\n  // The children will get the injector by resolve inheritance.\n  const newParentStates = newStateObjects.filter(state => !inArray(newStateObjects, state.parent));\n\n  // Add the Injector to the top of the lazy loaded state tree as a resolve\n  newParentStates.forEach(state => state.resolvables.push(Resolvable.fromData(NATIVE_INJECTOR_TOKEN, injector)));\n\n  return {};\n}\n\n/**\n * Returns the new dependency injection values from the Child Injector\n *\n * When a DI token is defined as multi: true, the child injector\n * can add new values for the token.\n *\n * This function returns the values added by the child injector,  and excludes all values from the parent injector.\n *\n * @internalapi\n */\nexport function multiProviderParentChildDelta(parent: Injector, child: Injector, token: any) {\n  const childVals: RootModule[] = child.get(token, []);\n  const parentVals: RootModule[] = parent.get(token, []);\n  return childVals.filter(val => parentVals.indexOf(val) === -1);\n}\n"
  ]
}